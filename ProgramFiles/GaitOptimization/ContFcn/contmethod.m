function q = contmethod(Hfcn,q0,options)
    %%%%%%%%%%%%%
    % It is an implementation of the Predictor-Corrector Continuation Method.
    % To find the solution of the function H(q) = 0, it takes two steps:
    % predictor and corrector steps. The predictor steps predict the point
    % in the future, and the corrector steps adjust the the predicted point
    % to correct the actual point. The predictor steps take the vector in
    % the tangent space of solution curve. The corrector steps are based on
    % the Newton-Rhapson method for solving H(q) = 0.
    %
    %
    % Inputs:
    %
    % Hfcn : The function to solve. It is an anonymous function.
    %   [H, JH, contdir] = Hfcn(q).
    % q0: The initial point for the continuation variables.
    % options: the option arguments generated by pcoptions().
    %
    % Outputs:
    %
    % q : The solutions from the Predictor-Corrector Method. It contains
    % the solutions as the column vector. The row number corresponds to the
    % i-th solutions.
    %
    %%%%%%%%%%%%%

    % Default value
    arguments
        Hfcn
        q0
        options = []
    end

    if strcmpi(options.algorithm,'PredCor')
        options.algorithm = 1;
    elseif strcmpi(options.algorithm,'PseudoArcLen')
        options.algorithm = 2;
    end

    % adjust null tolerance.
    if options.nullHSize ~= 0
        [~, JH] = Hfcn(q0);
        while true
            nullH = null(JH,options.nulltol);
            if size(nullH,2) > options.nullHSize
                options.nulltol = options.nulltol*(1-options.alpha);
            elseif size(nullH,2) < options.nullHSize
                options.nulltol = options.nulltol*(1+options.alpha);
            else
                break;
            end
        end
    end

    q = zeros(length(q0),options.iterlimit);
    JHrank = zeros(1,options.iterlimit);
    q(:,1) = q0;

    try
    for i = 1:options.iterlimit

        % predictor step
        [H, JH, projvec,stop] = Hfcn(q(:,i));

        tH = predictor(JH,projvec,options);

        v = q(:,i) + options.h*tH;

        % corrector step
        j = 0;

        if stop
            break;
        end

        while true
            j = j + 1;

            [H,JH] = Hfcn(v);

            if options.algorithm == 1
                w = pc_corrector(v,H,JH,options);
            else
                w = pal_corrector(v,q(:,i),tH,H,JH,options);
            end

            if isfunction(options.ncpfcn)
                try
                    w = options.ncpfcn(w);
                catch ME
                    disp("The ncp function is ill-defined.")
                    rethrow(ME);
                end
            end

            if norm(w-v) < options.breaktol
                break;
            end

            v = w;

            if j >= options.corrlimit
                disp("The iteration of corrector exceeded the limit.")
                break;
            end
        end
        JHrank(i) = rank(JH,options.nulltol);
        q(:,i+1) = w;

        fprintf("c: %d, corrector iter: %d, optimality: %d \n",q(end,i+1),j,H(1));

        % For sysplotter, visualize the processing gait.
        if isfunction(options.outfcn)
            try
                if options.outfcn(q(:,i+1),i+1)
                    break;
                end
            catch ME
                disp("The output function is ill-defined.")
                rethrow(ME);
            end
        end

        if i > 2
            if (q(end,i+1)-q(end,i))*(q(end,i)-q(end,i-1)) < 0
                disp("The continuation direction is reversed!");
            end
        end

        if i > 10
            if std(q(end,1:11))/std(q(end,i-10:i)) > 30
                disp("The solution is not changed!");
                break;
            end
        end

        if abs(H(1)) > options.opttol
            fprintf("It is a suboptimal point! Optimality %d < tolerance %d. \n",abs(H(1)), options.opttol);
            break;
        end
    end
    q(:,i:end) = [];
    catch ME
        disp(ME.identifier);
        warning(ME.message);
        q(:,i:end) = [];
    end
end

function tH = predictor(JH,projvec,options)

    nullH = null(JH,options.nulltol);

    tH = zeros(size(nullH,1),1);

    for j = 1:size(nullH,2)
        tH=tH+(nullH(:,j).'*projvec)/norm(nullH(:,j))^2*nullH(:,j);
    end

end

function w = pc_corrector(v,H,JH,options)
    w = v - pinv(JH,options.nulltol)*H;
end

function w = pal_corrector(v,q0,tH,H,JH,options)

    M = [H; tH.'*(v-q0)-options.h];
    JM = [JH; tH.'];

    w = v - pinv(JM,options.nulltol)*M;
end
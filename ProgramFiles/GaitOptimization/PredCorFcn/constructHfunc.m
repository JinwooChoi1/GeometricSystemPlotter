function [H,JH] = constructHfunc(y,obj,const,gopt)
    %%%%%%%%%%%
    %
    %   This function constructs the system of equations and Jacobian matrix
    %   for solving a nonlinear parametric programming.
    %   It handles both equality and inequality constraints
    %   and continuate the Lagrangian function components accordingly.
    %
    % Inputs:
    %
    % y: input vector
    % obj: struct containing objective function components.
    % const: s truct containing constraint function components.
    % gopt: struct generated by optimalgaitoptions().
    %
    % Outputs:
    %
    % H: system of equations for Lagrange multiplier
    %   - 1st subvector: The Stationarity conditions of KKT.
    %   - 2nd subvector: The complementary problems of KKT.
    %   - 3rd subvector: The norm of multiplier should be 1.
    %   - 4th subvector: The variational equality constraint(s)
    %   which contain the parameter c.
    % JH: Jacobian of the system
    %
    %%%%%%%%%%%

    A = gopt.A;
    b = gopt.b;
    nfparam = gopt.nfparam;
    dimension = gopt.dimension;

    if isfield(gopt,"neq")
        neq = gopt.neq;
    else
        neq = 1;
    end

    nptotal = (nfparam-1)*dimension;

    [~,sigma,lambda,mu,c] = contvardistributor(y,gopt);

    % if the gait optimization does not have inequality constraints
    if isempty(mu)
        lagrgf = obj.gf*sigma;
        lagrhf = obj.hf*sigma;
        ineq.gf = [];
        nineq = 0;
        H = [];
        JH = [];
    else
        % Build the value and the gradient of the inequality constraint.
        A(:,nfparam*(1:dimension)) = [];
        ineq.f = A*y(1:nptotal)-b;
        ineq.gf = A.';

        % Calculate the value and the gradient of the Fischer-Burmeister
        % function. It handles the complementary problem of KKT condition.
        nineq = length(ineq.f);
        dmudX = zeros(nineq,1);
        dpdX = zeros(nptotal,nineq);
        H = zeros(nineq,1);
        for i = 1:nineq
            [H(i),dX] = fischerburmfunc(mu(i),ineq.f(i),ineq.gf(:,i));
            dmudX(i) = dX{1};
            dpdX(:,i) = dX{2};
        end
        dmudX = diag(dmudX);

        lagrgf = obj.gf*sigma + ineq.gf*mu;
        lagrhf = obj.hf*sigma;
        JH = [dpdX.' zeros(nineq,neq+1) dmudX zeros(nineq,1)];
    end

    if neq > 1
        for i = 1:neq
            lagrgf = lagrgf + const{i}.gf*lambda(i);
            lagrhf = lagrhf + const{i}.hf*lambda(i);
        end
        lagrhf = [lagrhf obj.gf];
        for i = 1:neq
            lagrhf = [lagrhf const{i}.gf];
        end
        lagrhf = [lagrhf ineq.gf zeros(nptotal,1)];
    else
        lagrgf = lagrgf + const.gf*lambda;
        lagrhf = lagrhf + const.hf*lambda;
        lagrhf = [lagrhf obj.gf const.gf ineq.gf zeros(nptotal,1)];
    end


    % build the system of equations for Lagrange multiplier.
    H = [lagrgf;
        H;
        sigma^2+norm(lambda)^2+norm(mu)^2-1];

    % build the Jacobian of the system.
    JH = [lagrhf;
        JH;
        zeros(1,nptotal) 2*sigma 2*lambda.' 2*mu.' zeros(1,1)];

    if iscell(const)
        for i = 1:neq
            H = [H; const{i}.f];
            JH = [JH; const{i}.gf.' zeros(1,nineq+neq+2)];
        end
        H(end) = const{neq}.f - c;
        JH(end,end) = -1;
    else
        H = [H; const.f - c];
        JH = [JH; const.gf.' zeros(1,nineq+neq+1) -1];
    end
end